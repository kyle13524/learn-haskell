module Lists where
import Data.Char

-- 9 Lists


-- Lists do double duty in Haskell.
-- 1. Lists serve as a way to refer to and process a collection or plurality of values
-- 2. Lists serve as an infinite series of values, usually generated by a function, allowing them
-- to act as a stream datatype

-- 9.2 The List Datatype

-- data []   a   =   []   |   a : [a]
--     [1]  [2] [3]  [4] [5]   [6]

-- 1. The datatype with the type constructor []
-- 2. Takes a single type constructor argument
-- 3. At the term level can be constructed via
-- 4. Nullary constructor
-- 5. OR it can be constructed by
-- 6. data constructor (:) which is product of value of type a and value
-- of type [a]


-- 9.3 Pattern matching on lists

-- We can pattern match on data constructors, so the data constructors in
-- list are no exception

myHead :: [a] -> a
myHead (x:_) = x

myTail :: [a] -> [a]
myTail [] = []
myTail (_:xs) = xs

-- We can add a base case to handle empty lists, but we can also use Maybe.
-- We don't always have a valid base case, like in myHead. Maybe is the solution.

safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (_:[]) = Nothing
safeTail (_:xs) = Just xs


-- 9.4 List's syntactic sugar

-- You can write [1, 2, 3] ++ [4] rather than (1 : 2 : 3 : []) ++ 4 : []
-- It will successively cons all of the elements together to form a list

-- Cons cells: The result of recursively prepending a value to the a list
-- Spines: Connective structure that holds the cons cells in place


-- 9.5 Using ranges to construct lists

list1 = [1..10]
list1' = enumFromTo 1 10 -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list2 = [1, 2..10] -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list2' = enumFromThenTo 1 2 10 -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list3 = [1, 3..10] -- [1, 3, 5, 7, 9]
list3' = enumFromThenTo 1 3 10
list4 = ['t'..'z']
list4' = enumFromTo 't' 'z'


-- 9.6 Extracting portions of lists

take' = take 7 ['a'..'z'] -- Get seven items from the list
drop' = drop 8 ['a'..'z'] -- Same as take but removes items from the list
splitAt' = splitAt 5 [1..10] -- Cut list into two parts

takeWhile' = takeWhile (<3) [1..10] -- Get elements from list until condition is met
takeWhile'' = takeWhile (=='a') "abracadabra"
dropWhile' = dropWhile (<3) [1..10] -- Drop elements from list until condition is met
dropWhile'' = dropWhile (<8) (enumFromTo 5 15)


-- Exercise: Thy Fearful Symmetry

-- 1. Using takeWhile and dropWhile, write a function that takes a string
-- and returns a list of strings, using spaces to separate the elements
-- of the string into words, as in the following sample:


stringSplit :: String -> Char -> [String]
stringSplit s del = go s del []
  where go str delim list
          | str == "" = reverse list
          | otherwise = go (snd $ splitAt 1 (dropWhile (/=delim) str)) delim ((:) (takeWhile(/=delim) str) list)

myWords :: String -> [String]
myWords s = stringSplit s ' '

firstSen = "Tyger Tyger, burning bright\n"
secondSen = "In the forests of the night\n"
thirdSen = "What immortal hand or eye\n"
fourthSen = "Could frame thy fearful symmetry?"
sentences = firstSen ++ secondSen ++ thirdSen ++ fourthSen

myLines :: String -> [String]
myLines s = stringSplit s '\n'

shouldEqual =
  [ "Tyger Tyger, burning bright"
  , "In the forests of the night"
  , "What immortal hand or eye"
  , "Could frame thy fearful symmetry?"
  ]

main :: IO ()
main =
  print $
  "Are they equal? "
  ++ show (myLines sentences == shouldEqual)


-- 9.7 List comprehensions
-- Based on the concept of set comprehensions in mathematics.
-- Must have at least one list which is the generator which gives
-- input to the comprehension.

-- Example:
-- [ x ^ 2 | x <- [1..10] ]
--   [1]  [2]     [  3  ]

-- 1. Output function that we apply to the members of the list
-- 2. The pipe separates the output function from the input
-- 3. The input set: consists of a generator and a variable

-- Notes:
-- Can add a predicate to limit the elements drawn from the generator
-- Can have multiple generator functions

example1 :: (Enum a, Num a, Ord a) => [a]
example1 = [x ^ y | x <- [1..10], y <- [2, 3], x ^ y < 200]

-- Executes like this: x1 ^ y1, x1 ^ y2, x1 ^ y3 ... x2 ^ y1

example2 = [(x, y) | x <- [1, 2, 3], y <- [6, 7]]
example3 = [(x, y) | x <- [1..3], y <- ['a'..'b']]

mySqr = [x ^ 2 | x <- [1..10]]
example4 = [(x, y) | x <- mySqr, y <- [1..3], x < 4]

-- Exercise: Comprehend thy lists

exercise1 = [x | x <- mySqr, rem x 2 == 0]
exercise2 = [(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
exercise3 = take 5 [(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]

-- List comprehensions with Strings
-- Since strings are also lists, we can use them in list comprehensions
-- elem is a useful function that tells us whether an element is in a list

lcstring = elem 'a' "abracadabra" -- True
lcstring2 = elem 'a' "Julie" -- False

threeLetterAcronym = [x | x <- "Three Letter Acronym", elem x ['A'..'Z']]
acro xs = [x | x <- xs, elem x ['A'..'Z']]

-- Exercise: Square Cube

mySqr' = [x^2 | x <- [1..5]]
myCube = [x^3 | x <- [1..5]]

mySqrCube = [(x, y) | x <- mySqr', y <- myCube]
mySqrCube' = [(x, y) | x <- mySqr', y <- myCube, x < 50, y < 50]
mySqrCube'' = length $ mySqrCube'


-- 9.8 Spines & non-strict evaluation

-- Data structures in Haskell have Spines
-- Spine: The connective structure that ties a collection of values together
-- In the case of a list, the recursive cons operator is the spine
-- Ex. [1, 2] == 1 : (2 : [])

-- When we build a list it proceeds from the bottom of the list and up the spine,
-- first putting in the 2, and then the 1.
-- Evaluation is non-strict, so the nodes are only constructed when being consumed.

-- Using :sprint command
-- Visualizes what has been evaluated already, using _ to represent unevaluated
-- expressions.

-- Using REPL:
-- blah = enumFromTo 'a' 'z' | :sprint blah = _
-- take 1 blah | :sprint blah = 'a' : _
-- take 2 blah | :sprint blah = 'a' : 'b' : _

-- * The example above shows how evaluation only happens when the nodes are being consumed * --

-- The 'length' function is only strict in the spine, meaning it only forces
-- evaluation on the spine of a list, not the values. When we use length on blah,
-- :sprint will behave as though we had forced evaluation of the values as well.

-- length blah | 24
-- :sprint blah | blah = "abcdefghijklmnopqrstuvwxyz"

-- * Spines are evaluated independently of values * --

-- Values in Haskell get evaluated to Weak-Head Normal-Form (WHNF) by default.
-- Normal form means the expression is fully evaluated, WHNF means the expression
-- is only evaluated as far as necessary to reach a data constructor.

-- (1, 2) -- WHNF & NF
-- (1, 1 + 1) -- WHNF
-- \x -> x * 10 -- WHNF & NF

-- "Papu" ++ "chon" -- Neither
-- Outermost component (++) is a function, whose arguments are fully applied
-- (1, "Papu" ++ "chon") -- WHNF because the list hasn't been evaluated

-- Length is strict in the spine. Using length on a list forces evaluation of the spine
-- without evaluating the values. This is shown below:

x = [1, undefined]
-- length x -- 2
-- This evaluates because bottom is not part of the spine 

x' = [1] ++ undefined ++ [3]
-- x' -- Exception: Prelude.undefined
-- This doesn't evaluate because bottom is part of the spine

length' :: [a] -> Integer
length' [] = 0
length' (_:xs) = 1 + length' xs

-- In order for sum to return a result it must evaluate all elements in the list
-- This function is spine and value strict.
mySum :: Num a => [a] -> a
mySum [] = 0
mySum (x : xs) = x + mySum xs

-- Exercise: Bottom Madness

-- Will it blow up?

-- 1. [x^y | x <- [1..5], y <- [2, undefined]] -- blow up
-- 2. take 1 $ [x^y | x <- [1..5], y <- [2, undefined]] -- okay
-- 3. sum [1, undefined, 3] -- blow up
-- 4. length [1, 2, undefined] -- okay
-- 5. length $ [1, 2, 3] ++ undefined -- blow up
-- 6. take 1 $ filter even [1, 2, 3, undefined] -- okay
-- 7. take 1 $ filter even [1, 3, undefined] -- blow up
-- 8. take 1 $ filter odd [1, 3, undefined] -- okay
-- 9. take 2 $ filter odd [1, 3, undefined] -- okay
-- 10. take 3 $ filter odd [1, 3, undefined] -- blow up


-- Section 9.9 Transforming lists of values

-- * Since Haskell uses non-strict evaluation, we tend to use higher-order functions
-- for transforming data rather than manually recursing over and over * --

-- map is defined as such:
myMap :: (a -> b) -> [a] -> [b]
myMap _ [] = []
myMap f (x : xs) = f x : map f xs

-- mapf[1,2,3]==[f1,f2,f3]
-- map (+1) [1, 2, 3]
-- [(+1) 1, (+1) 2, (+1) 3]
-- [2, 3, 4]

myMap' = take 2 $ map (+1) [1, 2, undefined]
-- same rules apply to the spine of this operation

mapFirsts = map fst [(2, 3), (4, 5), (6, 7), (8, 9)]
fmapFirsts = fmap fst [(2, 3), (4, 5), (6, 7), (8, 9)]

-- We can also map a partially applied function
mapTake3 = map (take 3) [[1..5], [1..5], [1..5]]

-- Can also map an if-then-else over the list
negate3rds = map (\x -> if x `mod` 3 == 0 then (-x) else (x)) [1..10]

-- Exercise: More Bottoms

-- Will the following expressions return a value?
ex1 = take 1 $ map (+1) [undefined, 2, 3] -- Bottom
ex2 =  take 1 $ map (+1) [1, undefined, 3] -- 1
ex3 = take 2 $ map (+1) [1, undefined, 3] -- Bottom

-- What does this function do?
itIsMystery xs =
  map (\x -> elem x "aeiou") xs
  -- Maps over a list of characters and returns whether the letter
  -- is a vowel. Returns a list ex. itIsMystery "hello" = [False, True, False, False, True]

-- What will be the result?
exA = map (^2) [1..10] -- List of squares
exB = map minimum [[1..10], [10..20], [20..30]] -- Minimum value of each list
exC = map sum [[1..5], [1..5], [1..5]] -- Sums up each list


-- Section 9.10 Filtering lists of values

-- Filter builds a nw list including values that meet the condition
filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' pred (x:xs)
 | pred x = x : filter' pred xs
 | otherwise = filter' pred xs

-- filter vs. list comprehension
filter1 = filter (\x -> elem x "aeiou") "abracadabra"
filter2 = [x | x <- "abracadabra", elem x "aeiou"]

-- Exercises:

filter3 = filter (\x -> x `mod` 3 == 0) [1..30]
filter4 = length . filter (\x -> x `mod` 3 == 0) $ [1..30]

removeFillerWords :: [[Char]] -> [[Char]]
removeFillerWords [] = []
removeFillerWords (x:xs)
  | x == "a" = removeFillerWords xs
  | x == "the" = removeFillerWords xs
  | x == "an" = removeFillerWords xs
  | otherwise = x : removeFillerWords xs

myFilter s = removeFillerWords . words $ s
myFilter2 s = filter (\x -> x /= "an" && x /= "a" && x /= "the") . words $ s
myFilter3 s = [ x | x <- words s, x /= "an", x /= "a", x /= "the"]


-- Section 9.11 Zipping lists


-- Zipping lists together is a means of combining values from multiple lists into a single list
-- Zipping stops as soon as one of the lists runs out of values

-- zip :: [a] -> [b] -> [(a, b)]

-- zipWith :: (a -> b -> c)
--            [     1     ]
--         -> [a] -> [b] -> [c]
--            [2]    [3]    [4]

-- 1. Function with two arguments. Types align with variables in the lists
-- 2. First input list
-- 3. Second input list
-- 4. Output list created from applying the function to the values of input lists

-- Examples:

zip1 = zipWith (+) [1, 2, 3] [10, 11, 12] -- [11, 13, 15]
zip2 = zipWith (*) [1, 2, 3] [10, 11, 12] -- [10, 22, 36]
zip3 = zipWith (==) ['a'..'f'] ['a'..'m']

-- Exercises:

myZip :: [a] -> [b] -> [(a, b)]
myZip [] _ = []
myZip _ [] = []
myZip (x:xs) (y:ys) =
  (x, y) : myZip xs ys


-- Section 9.12 Chapter Exercises


-- Data.Char

capitalizeFirst :: [Char] -> [Char]
capitalizeFirst (x:xs) =
  toUpper x : xs

capitalizeAll :: [Char] -> [Char]
capitalizeAll [] = []
capitalizeAll (x:xs) =
  toUpper x : capitalizeAll xs

-- Ciphers


