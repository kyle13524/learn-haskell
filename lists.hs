module Lists where

-- 9 Lists


-- Lists do double duty in Haskell.
-- 1. Lists serve as a way to refer to and process a collection or plurality of values
-- 2. Lists serve as an infinite series of values, usually generated by a function, allowing them
-- to act as a stream datatype

-- 9.2 The List Datatype

-- data []   a   =   []   |   a : [a]
--     [1]  [2] [3]  [4] [5]   [6]

-- 1. The datatype with the type constructor []
-- 2. Takes a single type constructor argument
-- 3. At the term level can be constructed via
-- 4. Nullary constructor
-- 5. OR it can be constructed by
-- 6. data constructor (:) which is product of value of type a and value
-- of type [a]


-- 9.3 Pattern matching on lists

-- We can pattern match on data constructors, so the data constructors in
-- list are no exception

myHead :: [a] -> a
myHead (x:_) = x

myTail :: [a] -> [a]
myTail [] = []
myTail (_:xs) = xs

-- We can add a base case to handle empty lists, but we can also use Maybe.
-- We don't always have a valid base case, like in myHead. Maybe is the solution.

safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (_:[]) = Nothing
safeTail (_:xs) = Just xs


-- 9.4 List's syntactic sugar

-- You can write [1, 2, 3] ++ [4] rather than (1 : 2 : 3 : []) ++ 4 : []
-- It will successively cons all of the elements together to form a list

-- Cons cells: The result of recursively prepending a value to the a list
-- Spines: Connective structure that holds the cons cells in place


-- 9.5 Using ranges to construct lists

list1 = [1..10]
list1' = enumFromTo 1 10 -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list2 = [1, 2..10] -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list2' = enumFromThenTo 1 2 10 -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list3 = [1, 3..10] -- [1, 3, 5, 7, 9]
list3' = enumFromThenTo 1 3 10
list4 = ['t'..'z']
list4' = enumFromTo 't' 'z'


-- 9.6 Extracting portions of lists

take' = take 7 ['a'..'z'] -- Get seven items from the list
drop' = drop 8 ['a'..'z'] -- Same as take but removes items from the list
splitAt' = splitAt 5 [1..10] -- Cut list into two parts

takeWhile' = takeWhile (<3) [1..10] -- Get elements from list until condition is met
takeWhile'' = takeWhile (=='a') "abracadabra"
dropWhile' = dropWhile (<3) [1..10] -- Drop elements from list until condition is met
dropWhile'' = dropWhile (<8) (enumFromTo 5 15)


-- Exercise: Thy Fearful Symmetry

-- 1. Using takeWhile and dropWhile, write a function that takes a string
-- and returns a list of strings, using spaces to separate the elements
-- of the string into words, as in the following sample:


stringSplit :: String -> Char -> [String]
stringSplit s del = go s del []
  where go str delim list
          | str == "" = reverse list
          | otherwise = go (snd $ splitAt 1 (dropWhile (/=delim) str)) delim ((:) (takeWhile(/=delim) str) list)

myWords :: String -> [String]
myWords s = stringSplit s ' '

firstSen = "Tyger Tyger, burning bright\n"
secondSen = "In the forests of the night\n"
thirdSen = "What immortal hand or eye\n"
fourthSen = "Could frame thy fearful symmetry?"
sentences = firstSen ++ secondSen ++ thirdSen ++ fourthSen

myLines :: String -> [String]
myLines s = stringSplit s '\n'

shouldEqual =
  [ "Tyger Tyger, burning bright"
  , "In the forests of the night"
  , "What immortal hand or eye"
  , "Could frame thy fearful symmetry?"
  ]

main :: IO ()
main =
  print $
  "Are they equal? "
  ++ show (myLines sentences == shouldEqual)


-- 9.7 List comprehensions
-- Based on the concept of set comprehensions in mathematics.
-- Must have at least one list which is the generator which gives
-- input to the comprehension.

-- Example:
-- [ x ^ 2 | x <- [1..10] ]
--   [1]  [2]     [  3  ]

-- 1. Output function that we apply to the members of the list
-- 2. The pipe separates the output function from the input
-- 3. The input set: consists of a generator and a variable

-- Notes:
-- Can add a predicate to limit the elements drawn from the generator
-- Can have multiple generator functions

example1 :: (Enum a, Num a, Ord a) => [a]
example1 = [x ^ y | x <- [1..10], y <- [2, 3], x ^ y < 200]

-- Executes like this: x1 ^ y1, x1 ^ y2, x1 ^ y3 ... x2 ^ y1

example2 = [(x, y) | x <- [1, 2, 3], y <- [6, 7]]
example3 = [(x, y) | x <- [1..3], y <- ['a'..'b']]

mySqr = [x ^ 2 | x <- [1..10]]
example4 = [(x, y) | x <- mySqr, y <- [1..3], x < 4]

-- Exercises: Comprehend thy lists

exercise1 = [x | x <- mySqr, rem x 2 == 0]
exercise2 = [(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
exercise3 = take 5 [(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]

-- List comprehensions with Strings
-- Since strings are also lists, we can use them in list comprehensions
-- elem is a useful function that tells us whether an element is in a list

lcstring = elem 'a' "abracadabra" -- True
lcstring2 = elem 'a' "Julie" -- False

threeLetterAcronym = [x | x <- "Three Letter Acronym", elem x ['A'..'Z']]
acro xs = [x | x <- xs, elem x ['A'..'Z']]

