module Lists where

-- 9 Lists


-- Lists do double duty in Haskell.
-- 1. Lists serve as a way to refer to and process a collection or plurality of values
-- 2. Lists serve as an infinite series of values, usually generated by a function, allowing them
-- to act as a stream datatype

-- 9.2 The List Datatype

-- data []   a   =   []   |   a : [a]
--     [1]  [2] [3]  [4] [5]   [6]

-- 1. The datatype with the type constructor []
-- 2. Takes a single type constructor argument
-- 3. At the term level can be constructed via
-- 4. Nullary constructor
-- 5. OR it can be constructed by
-- 6. data constructor (:) which is product of value of type a and value
-- of type [a]


-- 9.3 Pattern matching on lists

-- We can pattern match on data constructors, so the data constructors in
-- list are no exception

myHead :: [a] -> a
myHead (x:_) = x

myTail :: [a] -> [a]
myTail [] = []
myTail (_:xs) = xs

-- We can add a base case to handle empty lists, but we can also use Maybe.
-- We don't always have a valid base case, like in myHead. Maybe is the solution.

safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (_:[]) = Nothing
safeTail (_:xs) = Just xs


-- 9.4 List's syntactic sugar

-- You can write [1, 2, 3] ++ [4] rather than (1 : 2 : 3 : []) ++ 4 : []
-- It will successively cons all of the elements together to form a list

-- Cons cells: The result of recursively prepending a value to the a list
-- Spines: Connective structure that holds the cons cells in place


-- 9.5 Using ranges to construct lists

list1 = [1..10]
list1' = enumFromTo 1 10 -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list2 = [1, 2..10] -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list2' = enumFromThenTo 1 2 10 -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list3 = [1, 3..10] -- [1, 3, 5, 7, 9]
list3' = enumFromThenTo 1 3 10
list4 = ['t'..'z']
list4' = enumFromTo 't' 'z'


-- 9.6 Extracting portions of lists

take' = take 7 ['a'..'z'] -- Get seven items from the list
drop' = drop 8 ['a'..'z'] -- Same as take but removes items from the list
splitAt' = splitAt 5 [1..10] -- Cut list into two parts

takeWhile' = takeWhile (<3) [1..10] -- Get elements from list until condition is met
takeWhile'' = takeWhile (=='a') "abracadabra"
dropWhile' = dropWhile (<3) [1..10] -- Drop elements from list until condition is met
dropWhile'' = dropWhile (<8) (enumFromTo 5 15)


-- Exercise: Thy Fearful Symmetry

-- 1. Using takeWhile and dropWhile, write a function that takes a string
-- and returns a list of strings, using spaces to separate the elements
-- of the string into words, as in the following sample:


stringSplit :: String -> Char -> [String]
stringSplit s del = go s del []
  where go str delim list
          | str == "" = reverse list
          | otherwise = go (snd $ splitAt 1 (dropWhile (/=delim) str)) delim ((:) (takeWhile(/=delim) str) list)

myWords :: String -> [String]
myWords s = stringSplit s ' '

firstSen = "Tyger Tyger, burning bright\n"
secondSen = "In the forests of the night\n"
thirdSen = "What immortal hand or eye\n"
fourthSen = "Could frame thy fearful symmetry?"
sentences = firstSen ++ secondSen ++ thirdSen ++ fourthSen

myLines :: String -> [String]
myLines s = stringSplit s '\n'

shouldEqual =
  [ "Tyger Tyger, burning bright"
  , "In the forests of the night"
  , "What immortal hand or eye"
  , "Could frame thy fearful symmetry?"
  ]

main :: IO ()
main =
  print $
  "Are they equal? "
  ++ show (myLines sentences == shouldEqual)


-- 9.7 List comprehensions
